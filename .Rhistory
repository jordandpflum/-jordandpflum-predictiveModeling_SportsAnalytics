predbreaks = seq(min(Y),max(Y),length=nclr+1)
#Same as above, but for residuals
residbreaks = seq(min(res),max(res),length=nclr+1) # borders of resid color bins
#Functions for finding the bins for a value
residmap <- function(e){
return(plotclr[cut(drop(e), residbreaks)]) ## cut sorts into bins
}
predmap <- function(y){
return(predcol[cut(drop(y),predbreaks)]) ## cut sorts into bins
}
par(mfrow=c(1,2))#Change the display window of plots
#In this case the window will become a matrix of 2 rows and 2 columns
#Plotting the maps
map('state', 'california') #Plot map of CA
mtext("Fitted values (k=10)", #Add text
cex=2) #Size of the text
points(test[,3:2], #Coordinates
col=predmap(near$fitted), #Using the bins to assign colors for each obs
pch=19, #Point type
cex=1) #Size of point
map('state', 'california')
mtext("Residuals (k=10)",cex=2)
points(test[,3:2], col=residmap(res), pch=19, cex=1)
#Dimension returns the dimensions of a df
#The first number is the number of rows, and the second is the number of columns
n=dim(CAdata)[1]
#Now, let us repeat the example using k-fold cv
kcv = 5 #number of folds
n0 = round(n/kcv,0) #Size of each fold
#Different values of neighbors
kk <- 1:100
#MSE matrix
out_MSE = matrix(0,
nrow = kcv, #number of rows
ncol = length(kk)) #number of columns
#Vector of indices that have already been used inside the for
used = NULL
#The set of indices not used (will be updated removing the used)
set = 1:n
for(j in 1:kcv){
if(n0<length(set)){ #If the set of 'not used' is > than the size of the fold
val = sample(set, size = n0) #then sample indices from the set
}
if(n0>=length(set)){ #If the set of 'not used' is <= than the size of the fold
val=set #then use all of the remaining indices as the sample
}
#Create the train and test matrices
train_i = train[-val,] #Every observation except the ones whose indices were sampled
test_i = test[val,] #The observations whose indices sampled
for(i in kk){
#The current model
near = kknn(Y ~ ., #The formula
train = train_i, #The train matrix/df
test = test_i, #The test matrix/df
k=i, #Number of neighbors
kernel = "rectangular") #Type of kernel (see help for more)
#Calculating the MSE of current model
aux = mean((test_i[,1]-near$fitted)^2)
#Store the current MSE
out_MSE[j,i] = aux
}
#The union of the indices used currently and previously
used = union(used,val)
#The set of indices not used is updated
set = (1:n)[-used]
#Printing on the console the information that you want
#Useful to keep track of the progress of your loop
cat(j,"folds out of",kcv,'\n')
}
#Calculate the mean of MSE for each k
mMSE = apply(out_MSE, #Receive a matrix
2, #Takes its columns (it would take its rows if this argument was 1)
mean) #And for each column, calculate the mean
par(mfrow=c(1,1)) #Redimension plot window to 1 row, 1 column
#Complexity x RMSE graph
plot(log(1/kk),sqrt(mMSE), #the values
xlab="Complexity (log(1/k))",
ylab="out-of-sample RMSE",
main = "California Housing (knn)",
col=4, #Color of line
lwd=2, #Line width
type="l", #Type of graph = line
cex.lab=1.2) #Size of labs
#Find the index of the minimum value of mMSE
best = which.min(mMSE)
#Inclusing text at specific coordinates of the graph
text(log(1/kk[best]),sqrt(mMSE[best])+0.01, #Coordinates
paste("k=",kk[best]),#The actual text
col=2, #Color of the text
cex=1.2) #Size of the text
text(log(1/100)+1,sqrt(mMSE[100]),"k=100")
text(log(1/1)-0.5,sqrt(mMSE[1])+0.001,"k=1")
#Now let us plot the maps again using the selected knn model
Income = scale(CAdata$medianIncome)*sd(CAdata$latitude)
Rooms = scale(CAdata$totalRooms)*sd(CAdata$latitude)
Age = scale(CAdata$housingMedianAge)*(CAdata$latitude)
train = data.frame(Y,CAdata$latitude,CAdata$longitude,Income,Rooms,Age)
test = data.frame(Y,CAdata$latitude,CAdata$longitude,Income,Rooms,Age)
#The model, but now also including income among the covariates
near = kknn(Y~.,train,test,k=best,kernel = "rectangular")
#Calculate the residuals
res = Y - near$fitted
#Number of colors
nclr = 10
#Color palette
plotclr = colorRampPalette(c("cyan","magenta"))(nclr) #This function interpolate
#two colors, so in this case, will be a palette with 10 different colors
#Same as above, but with heat colors
predcol = heat.colors(nclr)[(nclr):1] ## see help(heat.colors)
#Find the breaks between min and max of Y, such that we will have 9 bins
predbreaks = seq(min(Y),max(Y),length=nclr+1)
#Same as above, but for residuals
residbreaks = seq(min(res),max(res),length=nclr+1) # borders of resid color bins
#Functions for finding the bins for a value
residmap <- function(e){
return(plotclr[cut(drop(e), residbreaks)]) ## cut sorts into bins
}
predmap <- function(y){
return(predcol[cut(drop(y),predbreaks)]) ## cut sorts into bins
}
par(mfrow=c(1,2))#Change the display window of plots
#In this case the window will become a matrix of 2 rows and 2 columns
#Plotting the maps
map('state', 'california') #Plot map of CA
mtext(paste0("Fitted values (k=",best,")"), #Add text
cex=2) #Size of the text
points(test[,3:2], #Coordinates
col=predmap(near$fitted), #Using the bins to assign colors for each obs
pch=19, #Point type
cex=1) #Size of point
map('state', 'california')
mtext(paste0("Residuals (k=",best,")"),cex=2)
points(test[,3:2], col=residmap(res), pch=19, cex=1)
#Now let us plot the maps again using the selected knn model
Income = scale(CAdata$medianIncome)*sd(CAdata$latitude)
Rooms = scale(CAdata$totalRooms)*sd(CAdata$latitude)
Age = scale(CAdata$housingMedianAge)*(CAdata$latitude)
train = data.frame(Y,CAdata$latitude,CAdata$longitude,Income)
test = data.frame(Y,CAdata$latitude,CAdata$longitude,Income)
#The model, but now also including income among the covariates
near = kknn(Y~.,train,test,k=best,kernel = "rectangular")
#Calculate the residuals
res = Y - near$fitted
#Number of colors
nclr = 10
#Color palette
plotclr = colorRampPalette(c("cyan","magenta"))(nclr) #This function interpolate
#two colors, so in this case, will be a palette with 10 different colors
#Same as above, but with heat colors
predcol = heat.colors(nclr)[(nclr):1] ## see help(heat.colors)
#Find the breaks between min and max of Y, such that we will have 9 bins
predbreaks = seq(min(Y),max(Y),length=nclr+1)
#Same as above, but for residuals
residbreaks = seq(min(res),max(res),length=nclr+1) # borders of resid color bins
#Functions for finding the bins for a value
residmap <- function(e){
return(plotclr[cut(drop(e), residbreaks)]) ## cut sorts into bins
}
predmap <- function(y){
return(predcol[cut(drop(y),predbreaks)]) ## cut sorts into bins
}
par(mfrow=c(1,2))#Change the display window of plots
#In this case the window will become a matrix of 2 rows and 2 columns
#Plotting the maps
map('state', 'california') #Plot map of CA
mtext(paste0("Fitted values (k=",best,")"), #Add text
cex=2) #Size of the text
points(test[,3:2], #Coordinates
col=predmap(near$fitted), #Using the bins to assign colors for each obs
pch=19, #Point type
cex=1) #Size of point
map('state', 'california')
mtext(paste0("Residuals (k=",best,")"),cex=2)
points(test[,3:2], col=residmap(res), pch=19, cex=1)
#Calculate the residuals
res = Y - near$fitted
#Number of colors
nclr = 10
#Calculate the residuals
res = Y - near$fitted
#Now let us plot the maps again using the selected knn model
Income = scale(CAdata$medianIncome)*sd(CAdata$latitude)
Rooms = scale(CAdata$totalRooms)*sd(CAdata$latitude)
Age = scale(CAdata$housingMedianAge)*(CAdata$latitude)
train = data.frame(Y,CAdata$latitude,CAdata$longitude,Income,Rooms,Age)
test = data.frame(Y,CAdata$latitude,CAdata$longitude,Income,Rooms,Age)
#Now let us plot the maps again using the selected knn model
Income = scale(CAdata$medianIncome)*sd(CAdata$latitude)
Rooms = scale(CAdata$totalRooms)*sd(CAdata$latitude)
Age = scale(CAdata$housingMedianAge)*(CAdata$latitude)
train = data.frame(Y,CAdata$latitude,CAdata$longitude,Income,Rooms,Age)
test = data.frame(Y,CAdata$latitude,CAdata$longitude,Income,Rooms,Age)
train1 = data.frame(Y,CAdata$latitude,CAdata$longitude,Income)
test1 = data.frame(Y,CAdata$latitude,CAdata$longitude,Income)
#The model, but now also including income among the covariates
near = kknn(Y~.,train,test,k=best,kernel = "rectangular")
near1 = kknn(Y~.,train1,test1,k=best,kernel = "rectangular")
#Calculate the residuals
res = Y - near$fitted
res1 = Y - near1$fitted
#Now let us plot the maps again using the selected knn model
Income = scale(CAdata$medianIncome)*sd(CAdata$latitude)
Rooms = scale(CAdata$totalRooms)*sd(CAdata$latitude)
Age = scale(CAdata$housingMedianAge)*(CAdata$latitude)
train = data.frame(Y,CAdata$latitude,CAdata$longitude,Income,Rooms,Age)
test = data.frame(Y,CAdata$latitude,CAdata$longitude,Income,Rooms,Age)
train1 = data.frame(Y,CAdata$latitude,CAdata$longitude,Income)
test1 = data.frame(Y,CAdata$latitude,CAdata$longitude,Income)
#The model, but now also including income among the covariates
near = kknn(Y~.,train,test,k=best,kernel = "rectangular")
near1 = kknn(Y~.,train1,test1,k=best,kernel = "rectangular")
#Calculate the residuals
res = Y - near$fitted
res1 = Y - near1$fitted
#Number of colors
nclr = 10
#Color palette
plotclr = colorRampPalette(c("cyan","magenta"))(nclr) #This function interpolate
#two colors, so in this case, will be a palette with 10 different colors
#Same as above, but with heat colors
predcol = heat.colors(nclr)[(nclr):1] ## see help(heat.colors)
#Find the breaks between min and max of Y, such that we will have 9 bins
predbreaks = seq(min(Y),max(Y),length=nclr+1)
#Same as above, but for residuals
residbreaks = seq(min(res),max(res),length=nclr+1) # borders of resid color bins
residbreaks1 = seq(min(res1),max(res1),length=nclr+1)
#Functions for finding the bins for a value
residmap <- function(e){
return(plotclr[cut(drop(e), residbreaks)]) ## cut sorts into bins
residmap1 <- function(e){
return(plotclr[cut(drop(e), residbreaks1)])
}
predmap <- function(y){
return(predcol[cut(drop(y),predbreaks)]) ## cut sorts into bins
}
par(mfrow=c(1,2))#Change the display window of plots
#In this case the window will become a matrix of 2 rows and 2 columns
#Plotting the maps
map('state', 'california') #Plot map of CA
mtext(paste0("Fitted values (k=",best,")"), #Add text
cex=2) #Size of the text
points(test[,3:2], #Coordinates
col=predmap(near$fitted), #Using the bins to assign colors for each obs
pch=19, #Point type
cex=1) #Size of point
map('state', 'california')
mtext(paste0("Residuals (k=",best,")"),cex=2)
points(test[,3:2], col=residmap(res), pch=19, cex=1)
map('state', 'california') #Plot map of CA
mtext(paste0("Fitted values (k=",best,")"), #Add text
cex=2) #Size of the text
points(test[,3:2], #Coordinates
col=predmap(near1$fitted), #Using the bins to assign colors for each obs
pch=19, #Point type
cex=1) #Size of point
map('state', 'california')
mtext(paste0("Residuals (k=",best,")"),cex=2)
points(test[,3:2], col=residmap1(res1), pch=19, cex=1)
View(test1)
View(predmap)
residmap1 <- function(e){
return(plotclr[cut(drop(e), residbreaks1)])
residmap1 <- function(e){
return(plotclr[cut(drop(e), residbreaks1)])
View(residmap)
View(residmap)
View(predmap)
#Now let us plot the maps again using the selected knn model
Income = scale(CAdata$medianIncome)*sd(CAdata$latitude)
Rooms = scale(CAdata$totalRooms)*sd(CAdata$latitude)
Age = scale(CAdata$housingMedianAge)*(CAdata$latitude)
train = data.frame(Y,CAdata$latitude,CAdata$longitude,Income,Rooms,Age)
test = data.frame(Y,CAdata$latitude,CAdata$longitude,Income,Rooms,Age)
train1 = data.frame(Y,CAdata$latitude,CAdata$longitude,Income)
test1 = data.frame(Y,CAdata$latitude,CAdata$longitude,Income)
#The model, but now also including income among the covariates
near = kknn(Y~.,train,test,k=best,kernel = "rectangular")
near1 = kknn(Y~.,train1,test1,k=best,kernel = "rectangular")
#Calculate the residuals
res = Y - near$fitted
res1 = Y - near1$fitted
#Number of colors
nclr = 10
#Color palette
plotclr = colorRampPalette(c("cyan","magenta"))(nclr) #This function interpolate
#two colors, so in this case, will be a palette with 10 different colors
#Same as above, but with heat colors
predcol = heat.colors(nclr)[(nclr):1] ## see help(heat.colors)
#Find the breaks between min and max of Y, such that we will have 9 bins
predbreaks = seq(min(Y),max(Y),length=nclr+1)
#Same as above, but for residuals
residbreaks = seq(min(res),max(res),length=nclr+1) # borders of resid color bins
residbreaks1 = seq(min(res1),max(res1),length=nclr+1)
#Functions for finding the bins for a value
residmap <- function(e){
return(plotclr[cut(drop(e), residbreaks)]) ## cut sorts into bins
residmap1 <- function(e)
return(plotclr[cut(drop(e), residbreaks1)])
}
predmap <- function(y){
return(predcol[cut(drop(y),predbreaks)]) ## cut sorts into bins
}
par(mfrow=c(1,2))#Change the display window of plots
#In this case the window will become a matrix of 2 rows and 2 columns
#Plotting the maps
map('state', 'california') #Plot map of CA
mtext(paste0("Fitted values (k=",best,")"), #Add text
cex=2) #Size of the text
points(test[,3:2], #Coordinates
col=predmap(near$fitted), #Using the bins to assign colors for each obs
pch=19, #Point type
cex=1) #Size of point
map('state', 'california')
mtext(paste0("Residuals (k=",best,")"),cex=2)
points(test[,3:2], col=residmap(res), pch=19, cex=1)
map('state', 'california') #Plot map of CA
mtext(paste0("Fitted values (k=",best,")"), #Add text
cex=2) #Size of the text
points(test[,3:2], #Coordinates
col=predmap(near1$fitted), #Using the bins to assign colors for each obs
pch=19, #Point type
cex=1) #Size of point
map('state', 'california')
mtext(paste0("Residuals (k=",best,")"),cex=2)
points(test[,3:2], col=residmap1(res1), pch=19, cex=1)
#Dimension returns the dimensions of a df
#The first number is the number of rows, and the second is the number of columns
n=dim(CAdata)[1]
#Now, let us repeat the example using k-fold cv
kcv = 5 #number of folds
n0 = round(n/kcv,0) #Size of each fold
#Different values of neighbors
kk <- 1:100
#MSE matrix
out_MSE = matrix(0,
nrow = kcv, #number of rows
ncol = length(kk)) #number of columns
#Vector of indices that have already been used inside the for
used = NULL
#The set of indices not used (will be updated removing the used)
set = 1:n
for(j in 1:kcv){
if(n0<length(set)){ #If the set of 'not used' is > than the size of the fold
val = sample(set, size = n0) #then sample indices from the set
}
if(n0>=length(set)){ #If the set of 'not used' is <= than the size of the fold
val=set #then use all of the remaining indices as the sample
}
#Create the train and test matrices
train_i = train[-val,] #Every observation except the ones whose indices were sampled
test_i = test[val,] #The observations whose indices sampled
for(i in kk){
#The current model
near = kknn(Y ~ ., #The formula
train = train_i, #The train matrix/df
test = test_i, #The test matrix/df
k=i, #Number of neighbors
kernel = "rectangular") #Type of kernel (see help for more)
#Calculating the MSE of current model
aux = mean((test_i[,1]-near$fitted)^2)
#Store the current MSE
out_MSE[j,i] = aux
}
#The union of the indices used currently and previously
used = union(used,val)
#The set of indices not used is updated
set = (1:n)[-used]
#Printing on the console the information that you want
#Useful to keep track of the progress of your loop
cat(j,"folds out of",kcv,'\n')
}
#Calculate the mean of MSE for each k
mMSE = apply(out_MSE, #Receive a matrix
2, #Takes its columns (it would take its rows if this argument was 1)
mean) #And for each column, calculate the mean
par(mfrow=c(1,1)) #Redimension plot window to 1 row, 1 column
#Complexity x RMSE graph
plot(log(1/kk),sqrt(mMSE), #the values
xlab="Complexity (log(1/k))",
ylab="out-of-sample RMSE",
main = "California Housing (knn)",
col=4, #Color of line
lwd=2, #Line width
type="l", #Type of graph = line
cex.lab=1.2) #Size of labs
#Find the index of the minimum value of mMSE
best = which.min(mMSE)
#Inclusing text at specific coordinates of the graph
text(log(1/kk[best]),sqrt(mMSE[best])+0.01, #Coordinates
paste("k=",kk[best]),#The actual text
col=2, #Color of the text
cex=1.2) #Size of the text
text(log(1/100)+1,sqrt(mMSE[100]),"k=100")
text(log(1/1)-0.5,sqrt(mMSE[1])+0.001,"k=1")
min(mMSE)
}
}
]
}
residmap1 <- function(e)
return(plotclr[cut(drop(e), residbreaks1)])
View(residmap1)
map('state', 'california') #Plot map of CA
mtext(paste0("Fitted values (k=",best,")"), #Add text
cex=2) #Size of the text
points(test[,3:2], #Coordinates
col=predmap(near1$fitted), #Using the bins to assign colors for each obs
pch=19, #Point type
cex=1) #Size of point
map('state', 'california')
mtext(paste0("Residuals (k=",best,")"),cex=2)
points(test[,3:2], col=residmap1(res1), pch=19, cex=1)
load("C:/Users/jenni/Downloads/CAhousing.csv")
ca <- read.csv("CAhousing.csv")
ca <- read.csv("CAhousing.csv")
getwd()
setwd("Downloads")
#### knn model
set.seed(12345)
library(maps)
metrics <- read.csv("2017_player_salary_and_metrics.csv")
logSalary <- log(metrics$salary)
n=dim(metrics)[1]
getwd()
rm(list=ls())
# Dataframe Creation
source("DataWrangling/createCompleteDataframe.R")
# Load Data (Player Salary)
playerSalaryData<-read.csv("Data/PlayerSalary_Season/salaries_1985to2018.csv", stringsAsFactors = FALSE)
# Load Data (Player Season Metrics)
playerSeasonMetricsData<-read.csv("Data/PlayerMetrics_Season/player_metric_season.csv", stringsAsFactors = FALSE)
completeDataframe <- createCompleteDataframeTotal(playerSalaryData=playerSalaryData,
playerSeasonMetricsData=playerSeasonMetricsData,
year_start=2010,
year_end=2017)
# Grouping
# Gruping by Position
# Grouping by Age.
source("Classification/createAgeGroupingDataframe.R")
ageGroupedDataframe_18_22 <- createAgeGroupingDataframe(completeDataframe, ageGroup='18 - 22')
ageGroupedDataframe_23_26 <- createAgeGroupingDataframe(completeDataframe, ageGroup='23 - 26')
ageGroupedDataframe_27_30 <- createAgeGroupingDataframe(completeDataframe, ageGroup='27 - 30')
ageGroupedDataframe_31_35 <- createAgeGroupingDataframe(completeDataframe, ageGroup='31 - 35')
ageGroupedDataframe_over35 <- createAgeGroupingDataframe(completeDataframe, ageGroup='>35')
getwd()
setwd('C:/MSBA (PC)/GitHub/predictiveModelingSportsAnalytics')
rm(list=ls())
# Dataframe Creation
source("DataWrangling/createCompleteDataframe.R")
# Load Data (Player Salary)
playerSalaryData<-read.csv("Data/PlayerSalary_Season/salaries_1985to2018.csv", stringsAsFactors = FALSE)
# Load Data (Player Season Metrics)
playerSeasonMetricsData<-read.csv("Data/PlayerMetrics_Season/player_metric_season.csv", stringsAsFactors = FALSE)
completeDataframe <- createCompleteDataframeTotal(playerSalaryData=playerSalaryData,
playerSeasonMetricsData=playerSeasonMetricsData,
year_start=2010,
year_end=2017)
?createCompleteDataframeTotal
source("Classification/createAgeGroupingDataframe.R")
ageGroupedDataframe_18_22 <- createAgeGroupingDataframe(completeDataframe, ageGroup='18 - 22')
ageGroupedDataframe_23_26 <- createAgeGroupingDataframe(completeDataframe, ageGroup='23 - 26')
ageGroupedDataframe_27_30 <- createAgeGroupingDataframe(completeDataframe, ageGroup='27 - 30')
ageGroupedDataframe_31_35 <- createAgeGroupingDataframe(completeDataframe, ageGroup='31 - 35')
ageGroupedDataframe_over35 <- createAgeGroupingDataframe(completeDataframe, ageGroup='>35')
plot(ageGroupedDataframe_18_22)
View(ageGroupedDataframe_18_22)
library(MASS)
# Dummy for position
pos <- factor(xDF$Pos)
xDF = createParitalDataframe(df = completeDataframe, colNames = variables)
colnames(xDF) <- variables
source("DataWrangling/createPartialDataframe.R")
variables = c("Pos", "Age", "G", "GS", "MP", "PTS", "AST", "TRB", "ORB", "DRB",
"STL", "BLK", "TOV", "PF", "FG", "FGA", "X2P", "X2PA", "X3P",
"FT", "FTA", "PER", "ORB_perc", "DRB_perc", "TRB_perc", "AST_perc",
"STL_perc", "BLK_perc", "TOV_perc", "USG_perc", "OWS", "DWS",
"WS", "WS_48", "OBPM", "DBPM", "BPM", "VORP", "TSA", "TS_perc",
"X3P_perc", "X2P_perc", "eFG_perc", "FT_perc")
xDF = createParitalDataframe(df = completeDataframe, colNames = variables)
colnames(xDF) <- variables
# Create Y-DF
variables = c("Salary")
yDF = createParitalDataframe(df = completeDataframe, colNames = variables)
rm(list=ls())
# Dataframe Creation
source("DataWrangling/createCompleteDataframe.R")
# Load Data (Player Salary)
playerSalaryData<-read.csv("Data/PlayerSalary_Season/salaries_1985to2018.csv", stringsAsFactors = FALSE)
# Load Data (Player Season Metrics)
playerSeasonMetricsData<-read.csv("Data/PlayerMetrics_Season/player_metric_season.csv", stringsAsFactors = FALSE)
completeDataframe <- createCompleteDataframeTotal(playerSalaryData=playerSalaryData,
playerSeasonMetricsData=playerSeasonMetricsData,
year_start=2010,
year_end=2017)
# Grouping
# Gruping by Position
# Grouping by Age.
source("Classification/createAgeGroupingDataframe.R")
ageGroupedDataframe_18_22 <- createAgeGroupingDataframe(completeDataframe, ageGroup='18 - 22')
ageGroupedDataframe_23_26 <- createAgeGroupingDataframe(completeDataframe, ageGroup='23 - 26')
ageGroupedDataframe_27_30 <- createAgeGroupingDataframe(completeDataframe, ageGroup='27 - 30')
ageGroupedDataframe_31_35 <- createAgeGroupingDataframe(completeDataframe, ageGroup='31 - 35')
ageGroupedDataframe_over35 <- createAgeGroupingDataframe(completeDataframe, ageGroup='>35')
source("DataWrangling/createPartialDataframe.R")
variables = c("Pos", "Age", "G", "GS", "MP", "PTS", "AST", "TRB", "ORB", "DRB",
"STL", "BLK", "TOV", "PF", "FG", "FGA", "X2P", "X2PA", "X3P",
"FT", "FTA", "PER", "ORB_perc", "DRB_perc", "TRB_perc", "AST_perc",
"STL_perc", "BLK_perc", "TOV_perc", "USG_perc", "OWS", "DWS",
"WS", "WS_48", "OBPM", "DBPM", "BPM", "VORP", "TSA", "TS_perc",
"X3P_perc", "X2P_perc", "eFG_perc", "FT_perc")
xDF = createParitalDataframe(df = completeDataframe, colNames = variables)
colnames(xDF) <- variables
